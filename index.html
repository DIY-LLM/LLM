<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LigChem3D Browser Simulator</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
h1 { margin-bottom: 10px; }
#controls { margin-bottom: 10px; }
#compoundInput { width: 400px; height: 50px; }
#viewer { width: 900px; height: 600px; border:1px solid black; margin-top: 10px; background-color: #f0f0f0; }
#dashboard { margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px; max-height:300px; overflow:auto; }
button { margin-right: 10px; margin-top: 5px; padding: 8px 15px; cursor: pointer; }
</style>
</head>
<body>
<h1>LigChem3D: Browser-Based Molecular Simulator</h1>

<div id="controls">
<textarea id="compoundInput" placeholder="Enter SMILES separated by commas">CCO,CC,O=C=O</textarea><br>
<button id="simulate">Visualize & Minimize</button>
<button id="merge" disabled>Merge Compounds</button>
<label>Temperature (K): <input type="number" id="temperature" value="300"></label>
<label>Solvent:Â 
<select id="solvent">
<option>Water</option>
<option>Organic</option>
<option>None</option>
</select>
</label>
</div>

<div id="viewer"></div>
<div id="dashboard"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/openchemlib/openchemlib-full.js"></script>

<script>
// --- THREE.JS GLOBAL SETUP (Runs immediately on script execution) ---

let scene, camera, renderer, controls;
let moleculeObjects = [];

function initViewer() {
    // 1. Scene and Camera Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    camera = new THREE.PerspectiveCamera(75, 900 / 600, 0.1, 2000);
    camera.position.set(0, 0, 40);

    // 2. Renderer Setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(900, 600);
    document.getElementById('viewer').appendChild(renderer.domElement);

    // 3. Lighting
    const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
    light1.position.set(50, 50, 100);
    scene.add(light1);
    const light2 = new THREE.AmbientLight(0x606060);
    scene.add(light2);

    // 4. Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.05;
    
    // 5. Start Render Loop
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    controls.update(); // MUST be called if damping is enabled
    renderer.render(scene, camera);
}

// --- OPENCHEMLIB-DEPENDENT LOGIC ---

// Global variable to hold the OCL context and molecule data
let OCL;
let moleculesData = [];

// Atom color map (simplified CPK-style)
function getAtomColor(atomLabel) {
    switch (atomLabel) {
        case 'O': return 0xff0000; // Red (Oxygen)
        case 'N': return 0x0000ff; // Blue (Nitrogen)
        case 'F': case 'Cl': case 'Br': case 'I': return 0x00ff00; // Green (Halogens)
        case 'H': return 0xffffff; // White (Hydrogen)
        default: return 0x333333; // Dark Gray (Carbon and others)
    }
}

function loadLigAdvisorData() {
    return {
        "CCO": { "name": "Ethanol", "targets": ["ADH1A", "ADH1B"] },
        "CC": { "name": "Ethane", "targets": [] },
        "O=C=O": { "name": "Carbon dioxide", "targets": ["Carbonic Anhydrase"] },
    };
}

function minimizeMolecule(mol) {
    try {
        mol.addImplicitHydrogens();
        mol.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);
        OCL.Molecule3D.generate3DCoordinates(mol);
        OCL.MMFF94.optimize(mol);

        // Center molecule coordinates
        let n = mol.getAllAtoms(), cx = 0, cy = 0, cz = 0;
        for (let i = 0; i < n; i++) {
            cx += mol.getAtomX(i); cy += mol.getAtomY(i); cz += mol.getAtomZ(i);
        }
        cx /= n; cy /= n; cz /= n;
        for (let i = 0; i < n; i++) {
            mol.setAtomX(i, mol.getAtomX(i) - cx);
            mol.setAtomY(i, mol.getAtomY(i) - cy);
            mol.setAtomZ(i, mol.getAtomZ(i) - cz);
        }
        return mol;
    } catch (e) {
        // Fallback: only generate 3D coordinates if minimization fails
        OCL.Molecule3D.generate3DCoordinates(mol);
        return mol;
    }
}

function createBondCylinder(start, end, radius, color) {
    const length = start.distanceTo(end);
    const cylinder = new THREE.Mesh(
        new THREE.CylinderGeometry(radius, radius, length, 8),
        new THREE.MeshPhongMaterial({ color: color || 0xaaaaaa })
    );

    cylinder.position.set((start.x + end.x) / 2, (start.y + end.y) / 2, (start.z + end.z) / 2);
    cylinder.lookAt(end);
    cylinder.rotateX(Math.PI / 2);

    return cylinder;
}

function renderMolecule(mol, offsetX = 0) {
    const group = new THREE.Group();
    const atomRadius = 0.7;
    const bondRadius = 0.2;

    // 1. Render Atoms
    for (let i = 0; i < mol.getAllAtoms(); i++) {
        const atomLabel = mol.getAtomLabel(i);
        const color = getAtomColor(atomLabel);
        
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(atomRadius, 32, 32),
            new THREE.MeshPhongMaterial({ color: color })
        );
        sphere.position.set(mol.getAtomX(i) + offsetX, mol.getAtomY(i), mol.getAtomZ(i));
        group.add(sphere);
    }

    // 2. Render Bonds
    for (let b = 0; b < mol.getAllBonds(); b++) {
        const atomIdx1 = mol.getBondAtom(b, 0); 
        const atomIdx2 = mol.getBondAtom(b, 1);
        
        const p1 = new THREE.Vector3(mol.getAtomX(atomIdx1) + offsetX, mol.getAtomY(atomIdx1), mol.getAtomZ(atomIdx1));
        const p2 = new THREE.Vector3(mol.getAtomX(atomIdx2) + offsetX, mol.getAtomY(atomIdx2), mol.getAtomZ(atomIdx2));

        const cylinder = createBondCylinder(p1, p2, bondRadius, 0xaaaaaa);
        group.add(cylinder);
    }
    
    scene.add(group);
    moleculeObjects.push(group);
}

function updateDashboard(molArray) {
    const data = loadLigAdvisorData();
    const dashboard = document.getElementById('dashboard');
    dashboard.innerHTML = '<h2>Simulation Data</h2>';
    
    molArray.forEach((mol, index) => {
        const smiles = mol.toSmiles();
        const mass = mol.getMolecularFormula().mass;
        const info = data[smiles] || { name: 'Unknown', targets: ['None listed'] };

        const div = document.createElement('div');
        div.innerHTML = `<p><b>Compound ${index + 1}:</b> ${info.name}</p><ul><li>SMILES: <code>${smiles}</code></li><li>Mol. Weight: ${mass.toFixed(2)} g/mol</li><li>Predicted Targets: ${info.targets.join(', ')}</li></ul><hr>`;
        dashboard.appendChild(div);
    });
    
    const temperature = document.getElementById('temperature').value;
    const solvent = document.getElementById('solvent').value;
    const summary = document.createElement('div');
    summary.innerHTML += `<b>Simulation Conditions:</b> Temp: ${temperature}K, Solvent: ${solvent}`;
    dashboard.appendChild(summary);
}

function mergeMolecules() {
    if (moleculesData.length < 2) return;
    
    let merged = moleculesData[0];
    for(let i=1; i < moleculesData.length; i++) {
        merged = merged.merge(moleculesData[i]);
    }
    
    moleculesData = [minimizeMolecule(merged)];
    
    moleculeObjects.forEach(obj => scene.remove(obj));
    moleculeObjects = [];
    renderMolecule(moleculesData[0], 0);
    
    // Recenter camera
    camera.position.set(0, 0, 40);
    controls.target.set(0, 0, 0); 
    
    updateDashboard(moleculesData);
    document.getElementById('merge').disabled = true;
}

function simulate() {
    // This is where OCL is used, so it MUST be called after OCL loads.
    moleculeObjects.forEach(obj => scene.remove(obj));
    moleculeObjects = [];
    moleculesData = [];

    const input = document.getElementById('compoundInput').value.split(',').map(s => s.trim()).filter(s => s.length > 0);
    
    let offsetX = 0;
    const offsetStep = 15;

    input.forEach(smiles => {
        try {
            const mol = OCL.Molecule.fromSmiles(smiles);
            const minimized = minimizeMolecule(mol);
            moleculesData.push(minimized);
            renderMolecule(minimized, offsetX);
            offsetX += offsetStep;
        } catch (e) {
            console.error(`Error parsing or rendering SMILES: ${smiles}`, e);
        }
    });

    if (moleculesData.length > 0) {
        const totalWidth = offsetX - offsetStep;
        camera.position.set(totalWidth / 2, 0, 40);
        controls.target.set(totalWidth / 2, 0, 0);
    } else {
        camera.position.set(0, 0, 40);
        controls.target.set(0, 0, 0);
    }
    controls.update();

    updateDashboard(moleculesData);
    document.getElementById('merge').disabled = moleculesData.length < 2;
}

// --- INITIALIZATION SEQUENCE (Fixed) ---

// 1. Initialize Three.js/Viewer immediately
window.addEventListener('load', () => {
    initViewer();
    
    // 2. Initialize OCL and run simulate() *after* the promise resolves.
    OCL.OCL().then(lib => {
        OCL = lib; // Store the initialized OCL library globally
        
        // 3. RUN THE SIMULATION ON LOAD
        simulate(); 

        // 4. Attach event listeners *after* OCL is ready
        document.getElementById('simulate').addEventListener('click', simulate);
        document.getElementById('merge').addEventListener('click', mergeMolecules);

    }).catch(error => {
        document.getElementById('viewer').innerHTML = '<h2>Initialization Error</h2><p>Failed to load OpenChemLib. See console for details.</p>';
        console.error("OpenChemLib initialization failed:", error);
    });
});
</script>
</body>
</html>
