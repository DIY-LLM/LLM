<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>P2P Chat - Decentralized Messaging</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<style>
/* ... all your previous CSS remains unchanged ... */
</style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üîí P2P Secure Chat</h1>
        <p>Decentralized ‚Ä¢ No Servers ‚Ä¢ Private</p>
    </div>
    <div class="status">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
        </div>
        <div class="peer-id" id="peerId"></div>
    </div>

    <div class="main-content">
        <div class="setup-area" id="setupArea">
            <div class="info-box">
                ‚ÑπÔ∏è This chat uses WebRTC for direct peer-to-peer connections. No data passes through servers. Two people need to exchange connection codes to connect.
            </div>
            <div class="section">
                <h2>Option 1: Start a New Chat Room</h2>
                <button class="btn-primary" id="createRoom">Create Room</button>
                <div id="hostInstructions" class="hidden">
                    <div class="step-indicator">
                        <h3>üì§ Step 1: Share Your Offer Code</h3>
                        <p>Copy the code below and send it to your friend</p>
                    </div>
                    <div class="code-box" id="offerCode"></div>
                    <button class="btn-secondary" id="copyOffer">Copy Offer Code</button>
                    <div class="qr-container">
                        <div id="qrcode"></div>
                    </div>
                    <div class="step-indicator" style="margin-top: 20px;">
                        <h3>üì• Step 2: Wait for Answer Code</h3>
                        <p>Paste the answer code your friend sends:</p>
                    </div>
                    <textarea id="answerInput" placeholder="Paste the answer code from your friend here..."></textarea>
                    <button class="btn-success" id="submitAnswer">Connect</button>
                </div>
            </div>

            <div class="section">
                <h2>Option 2: Join Existing Room</h2>
                <div class="step-indicator">
                    <h3>üì• Paste Offer Code</h3>
                    <p>Paste the offer code you received from your friend:</p>
                </div>
                <textarea id="joinInput" placeholder="Paste offer code here..."></textarea>
                <button class="btn-success" id="joinRoom">Join Room</button>
                <div id="joinerInstructions" class="hidden">
                    <div class="warning-box">
                        ‚ö†Ô∏è Copy the answer code below and send it back to your friend!
                    </div>
                    <div class="code-box" id="answerCode"></div>
                    <button class="btn-secondary" id="copyAnswer">Copy Answer Code</button>
                    <div class="step-indicator" style="margin-top: 20px;">
                        <h3>‚è≥ Waiting for Connection...</h3>
                        <p>Once your friend pastes your answer code, the connection will be established automatically.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-area" id="chatArea">
            <div class="messages" id="messages"></div>
            <div class="message-input-area">
                <input type="text" id="messageInput" placeholder="Type a message...">
                <button class="btn-primary" id="sendBtn">Send</button>
            </div>
        </div>
    </div>
</div>

<script>
const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] };
let peerConnection = null, dataChannel = null, isInitiator = false, sessionKey = null;

const createRoomBtn = document.getElementById('createRoom');
const joinRoomBtn = document.getElementById('joinRoom');
const submitAnswerBtn = document.getElementById('submitAnswer');
const joinInput = document.getElementById('joinInput');
const answerInput = document.getElementById('answerInput');
const hostInstructions = document.getElementById('hostInstructions');
const joinerInstructions = document.getElementById('joinerInstructions');
const offerCode = document.getElementById('offerCode');
const answerCode = document.getElementById('answerCode');
const copyOfferBtn = document.getElementById('copyOffer');
const copyAnswerBtn = document.getElementById('copyAnswer');
const setupArea = document.getElementById('setupArea');
const chatArea = document.getElementById('chatArea');
const messages = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const peerId = document.getElementById('peerId');

// Random Peer ID
peerId.textContent = 'peer-' + Math.random().toString(36).substr(2, 9);

function waitForIceGathering(pc){ return new Promise(resolve=>{ if(pc.iceGatheringState==='complete') resolve(); else { const check=()=>{ if(pc.iceGatheringState==='complete'){ pc.removeEventListener('icegatheringstatechange',check); resolve(); } }; pc.addEventListener('icegatheringstatechange',check); }}); }

async function createHMAC(message, key){
    const enc = new TextEncoder();
    const cryptoKey = await crypto.subtle.importKey('raw', key, {name:'HMAC', hash:'SHA-256'}, false, ['sign']);
    const sig = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));
    return btoa(String.fromCharCode(...new Uint8Array(sig)));
}

async function verifyHMAC(message, hmac, key){
    const generated = await createHMAC(message,key);
    return generated === hmac;
}

async function initializePeerConnection(){
    peerConnection = new RTCPeerConnection(config);

    if(isInitiator){
        dataChannel = peerConnection.createDataChannel('chat');
        setupDataChannel();
    } else {
        peerConnection.ondatachannel = e => { dataChannel = e.channel; setupDataChannel(); };
    }

    peerConnection.onicecandidate = e => { console.log('ICE candidate:', e.candidate?'Found':'Complete'); };

    peerConnection.onconnectionstatechange = () => {
        if(peerConnection.connectionState==='connected'){
            updateStatus('connected','Connected & Encrypted');
            setupArea.classList.add('hidden');
            chatArea.classList.add('active');
            messageInput.focus();
            // Generate & exchange session key automatically
            if(isInitiator){
                sessionKey = crypto.getRandomValues(new Uint8Array(32));
                dataChannel.send(JSON.stringify({type:'sessionKey', key:btoa(String.fromCharCode(...sessionKey))}));
            }
        } else if(peerConnection.connectionState==='disconnected'||peerConnection.connectionState==='failed'){
            updateStatus('disconnected','Disconnected');
            alert('Connection lost. Refresh to start a new session.');
        } else if(peerConnection.connectionState==='connecting'){
            updateStatus('waiting','Connecting...');
        }
    };
}

function setupDataChannel(){
    dataChannel.onopen = () => { updateStatus('connected','Connected & Encrypted'); chatArea.classList.add('active'); setupArea.classList.add('hidden'); messageInput.focus(); };
    dataChannel.onclose = () => { updateStatus('disconnected','Disconnected'); alert('Connection lost.'); };
    dataChannel.onerror = e => console.error('Data channel error', e);
    dataChannel.onmessage = async e => {
        const data = JSON.parse(e.data);

        // Session key exchange
        if(data.type==='sessionKey'){
            sessionKey = Uint8Array.from(atob(data.key), c=>c.charCodeAt(0));
            console.log('Session key received');
            return;
        }

        // Normal message
        if(!sessionKey){ console.warn('No session key yet'); return; }
        if(await verifyHMAC(data.text,data.hmac,sessionKey)){
            addMessage(data.text,false,data.time);
        } else { console.warn('HMAC verification failed'); }
    };
}

async function sendMessage(){
    const text = messageInput.value.trim();
    if(!text || !dataChannel || dataChannel.readyState!=='open' || !sessionKey) return;
    const time = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
    const hmac = await createHMAC(text, sessionKey);
    dataChannel.send(JSON.stringify({text,hmac,time}));
    addMessage(text,true,time);
    messageInput.value='';
}

function addMessage(text,isSent,time){
    const div = document.createElement('div');
    div.className = `message ${isSent?'sent':'received'}`;
    div.innerHTML = `<div class="message-bubble">${escapeHtml(text)}<div class="message-time">${time}</div></div>`;
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
}

function escapeHtml(text){ const div=document.createElement('div'); div.textContent=text; return div.innerHTML; }

function updateStatus(state,text){ statusText.textContent=text; statusDot.className='status-dot'; if(state==='connected') statusDot.classList.add('connected'); else if(state==='waiting') statusDot.classList.add('waiting'); }

// Create Room
createRoomBtn.addEventListener('click', async ()=>{
    isInitiator=true; createRoomBtn.disabled=true; updateStatus('waiting','Creating room...');
    await initializePeerConnection();
    const offer = await peerConnection.createOffer(); await peerConnection.setLocalDescription(offer);
    await waitForIceGathering(peerConnection);
    const offerData = btoa(JSON.stringify({type:'offer',sdp:peerConnection.localDescription.sdp}));
    offerCode.textContent = offerData; hostInstructions.classList.remove('hidden');
    const qrData = window.location.origin+window.location.pathname+'?offer='+offerData;
    document.getElementById('qrcode').innerHTML=''; new QRCode(document.getElementById('qrcode'),{text:qrData,width:180,height:180});
    updateStatus('waiting','Waiting for peer to join...');
});

// Copy Offer
copyOfferBtn.addEventListener('click',()=>{navigator.clipboard.writeText(offerCode.textContent); copyOfferBtn.textContent='‚úì Copied!'; setTimeout(()=>copyOfferBtn.textContent='Copy Offer Code',2000);});

// Submit Answer
submitAnswerBtn.addEventListener('click', async ()=>{
    const answerData = answerInput.value.trim(); if(!answerData) return;
    try{
        const data = JSON.parse(atob(answerData));
        await peerConnection.setRemoteDescription({type:'answer', sdp:data.sdp});
        submitAnswerBtn.textContent='Connecting...'; submitAnswerBtn.disabled=true; updateStatus('waiting','Establishing connection...');
    } catch(e){alert('Invalid answer code'); console.error(e); submitAnswerBtn.disabled=false;}
});

// Join Room
joinRoomBtn.addEventListener('click', async ()=>{
    const offerDataStr = joinInput.value.trim(); if(!offerDataStr) return;
    try{
        const data = JSON.parse(atob(offerDataStr));
        isInitiator=false; joinRoomBtn.disabled=true; updateStatus('waiting','Joining room...');
        await initializePeerConnection();
        await peerConnection.setRemoteDescription({type:'offer', sdp:data.sdp});
        const answer = await peerConnection.createAnswer(); await peerConnection.setLocalDescription(answer);
        await waitForIceGathering(peerConnection);
        const answerData = btoa(JSON.stringify({type:'answer',sdp:peerConnection.localDescription.sdp}));
        answerCode.textContent = answerData; joinerInstructions.classList.remove('hidden'); updateStatus('waiting','Waiting for host to connect...');
    } catch(e){alert('Invalid offer code'); console.error(e); joinRoomBtn.disabled=false;}
});

// Copy Answer
copyAnswerBtn.addEventListener('click',()=>{navigator.clipboard.writeText(answerCode.textContent); copyAnswerBtn.textContent='‚úì Copied!'; setTimeout(()=>copyAnswerBtn.textContent='Copy Answer Code',2000);});

// Message send
sendBtn.addEventListener('click',sendMessage);
messageInput.addEventListener('keypress',e=>{if(e.key==='Enter') sendMessage();});

// Load offer from URL
window.addEventListener('load',()=>{
    const params = new URLSearchParams(window.location.search);
    const offerParam = params.get('offer');
    if(offerParam){joinInput.value=offerParam; joinInput.scrollIntoView({behavior:'smooth'});}
});
</script>
</body>
</html>

