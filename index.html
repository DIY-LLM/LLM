<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LLM Toolkit — Worker + Checkpoint Demo</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:20px;background:#f7f9fb}
    .card{background:#fff;padding:16px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.06);max-width:900px;margin:auto}
    h1{margin:0 0 12px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:6px;border:1px solid #d0d7de;background:#1f7be1;color:#fff;cursor:pointer}
    button.secondary{background:#6c757d}
    button.warn{background:#d9534f}
    #progressBar{height:20px;background:#e6eefc;border-radius:6px;overflow:hidden;margin-top:8px}
    #progressFill{height:100%;width:0;background:linear-gradient(90deg,#2b8cff,#0b6cff);color:#fff;text-align:center;font-size:12px;line-height:20px}
    pre{background:#0b1220;color:#bcd; padding:12px;border-radius:6px;overflow:auto;max-height:200px}
    label{display:block;margin-top:8px;font-weight:600}
    input[type="file"]{display:block;margin-top:8px}
    .small{font-size:0.9em;color:#444}
    .warntext{color:#b33}
  </style>
</head>
<body>
  <div class="card">
    <h1>LLM Toolkit — Background Training (Worker) + Checkpoints</h1>

    <div class="row">
      <button id="startBtn">Start New Training</button>
      <button id="resumeBtn" class="secondary">Resume from Checkpoint</button>
      <button id="pauseBtn" class="secondary">Pause</button>
      <button id="downloadBtn" class="secondary">Download Checkpoint</button>
      <button id="clearBtn" class="warn">Delete Checkpoint</button>
    </div>

    <label>Task ID (auto-generated, you can set your own)</label>
    <input id="taskIdInput" placeholder="optional: enter a UUID-ish id" style="padding:8px;width:100%;box-sizing:border-box">

    <label>Epochs</label>
    <input id="epochsInput" type="number" value="50" min="1" style="padding:8px;width:120px">

    <label>Save interval (ms)</label>
    <input id="saveIntervalInput" type="number" value="300000" min="1000" style="padding:8px;width:160px">
    <div style="margin-top:12px" class="small">
      The worker will post progress at least every 5s and checkpoint every save interval (default 300,000ms = 5min).
    </div>

    <div style="margin-top:16px">
      <div id="progressText" class="small">No task running.</div>
      <div id="progressBar"><div id="progressFill">0%</div></div>
      <div style="margin-top:8px" id="statusLog"><em>Worker logs will appear here.</em></div>
    </div>

    <hr style="margin:18px 0">

    <div>
      <strong>Checkpoint Storage</strong>
      <div class="small" style="margin-top:8px">
        The app uses <code>IndexedDB</code> to store checkpoints (<=50MB target). If the browser refuses to save,
        you'll be prompted to download the checkpoint file.
      </div>
      <div style="margin-top:12px">
        <button id="inspectBtn" class="secondary">Show Latest Checkpoint Info</button>
      </div>
      <pre id="inspectPre">No checkpoint inspected yet.</pre>
    </div>

    <hr style="margin:18px 0">

    <div>
      <strong>Error / Alerts</strong>
      <div id="alertBox" class="warntext small"></div>
    </div>
  </div>

<script>
/*
Main thread controller for training-worker.js
 - Creates worker
 - Sends start/resume/pause/save/load commands
 - Displays progress
 - Handles QuotaExceededError and offers download of checkpoint
 - Implements worker.onerror to avoid UI freeze
*/

const DB_NAME = 'llm_worker_checkpoints_v1';
const STORE_NAME = 'checkpoints';

let worker = null;
let currentTaskId = '';
let lastCheckpointMeta = null;

const startBtn = document.getElementById('startBtn');
const resumeBtn = document.getElementById('resumeBtn');
const pauseBtn = document.getElementById('pauseBtn');
const downloadBtn = document.getElementById('downloadBtn');
const clearBtn = document.getElementById('clearBtn');
const inspectBtn = document.getElementById('inspectBtn');

const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const statusLog = document.getElementById('statusLog');
const alertBox = document.getElementById('alertBox');
const inspectPre = document.getElementById('inspectPre');

function logStatus(msg){
  const t = new Date().toLocaleTimeString();
  statusLog.innerHTML = `<div>[${t}] ${escapeHtml(msg)}</div>` + statusLog.innerHTML;
}
function echoAlert(msg){
  alertBox.textContent = msg;
  setTimeout(()=>{ if(alertBox.textContent===msg) alertBox.textContent=''; }, 20000);
}
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function createWorker(){
  if (worker) {
    worker.terminate();
    worker = null;
  }
  worker = new Worker('training-worker.js');
  worker.onmessage = handleWorkerMessage;
  worker.onerror = (ev) => {
    console.error('Worker error', ev);
    logStatus('Worker error: ' + (ev.message || 'unknown'));
    echoAlert('Worker crashed — see console for details.');
  };
  logStatus('Worker created');
}

function handleWorkerMessage(ev){
  const msg = ev.data;
  if (!msg || !msg.type) return;
  switch(msg.type){
    case 'progress':
      updateProgress(msg);
      break;
    case 'log':
      logStatus(msg.text);
      break;
    case 'checkpoint-saved':
      lastCheckpointMeta = msg.meta;
      logStatus(`Checkpoint saved (step ${msg.meta.stepNumber}, ${new Date(msg.meta.timestamp).toLocaleString()})`);
      break;
    case 'checkpoint-error':
      if (msg.error && msg.error.name === 'QuotaExceededError') {
        // Worker couldn't save — pause worker and offer download
        logStatus('Checkpoint failed: quota exceeded.');
        echoAlert('Storage limit reached. Pausing worker so you can download the checkpoint.');
        pauseWorker().then(()=>{/*paused*/});
      } else {
        logStatus('Checkpoint error: ' + (msg.error && msg.error.message));
      }
      break;
    case 'ready':
      logStatus('Worker ready');
      break;
    case 'resumed':
      logStatus('Resumed from checkpoint (step ' + msg.step + ')');
      break;
    case 'saved-file':
      // Received checkpoint Blob as downloadable message (rare, normally main will download from IndexedDB)
      downloadBlob(msg.blob, msg.filename || 'checkpoint.bin');
      break;
    default:
      console.warn('Unknown worker msg', msg);
  }
}

function updateProgress({percentage, stepNumber, epochs, status}){
  const pct = Math.min(100, Math.max(0, Math.round(percentage)));
  progressFill.style.width = pct + '%';
  progressFill.textContent = pct + '%';
  progressText.textContent = `Step ${stepNumber || 0} — ${status || ''} — Epochs target: ${epochs || '?'}`
}

async function startNewWorker(){
  createWorker();
  const taskIdInput = document.getElementById('taskIdInput').value.trim();
  currentTaskId = taskIdInput || ('task-' + Date.now().toString(36));
  const epochs = Number(document.getElementById('epochsInput').value) || 50;
  const saveInterval = Number(document.getElementById('saveIntervalInput').value) || 300000;

  worker.postMessage({type:'start-new', payload:{
    taskId: currentTaskId,
    config: {
      epochs,
      saveInterval
    }
  }});
  logStatus('Sent start-new to worker (taskId=' + currentTaskId + ')');
}

async function resumeFromCheckpoint(){
  // Ask worker to resume; worker will load from IndexedDB itself if we send 'resume' and provide taskId
  createWorker();
  const taskIdInput = document.getElementById('taskIdInput').value.trim();
  currentTaskId = taskIdInput || null;
  worker.postMessage({type:'resume', payload:{taskId: currentTaskId}});
  logStatus('Sent resume to worker (taskId=' + (currentTaskId||'any') + ')');
}

async function pauseWorker(){
  if (!worker) return;
  worker.postMessage({type:'pause'});
  logStatus('Sent pause');
}

async function downloadLatestCheckpoint(){
  // We'll open IndexedDB and download the Blob for the latest checkpoint for currentTaskId (or newest)
  try{
    const meta = await inspectLatestCheckpoint(currentTaskId);
    if (!meta) {
      echoAlert('No checkpoint found to download.');
      return;
    }
    const {taskId, timestamp} = meta;
    const content = await readCheckpointBlob(taskId);
    if (!content) {
      echoAlert('Could not load checkpoint data for download.');
      return;
    }
    downloadBlob(content, `checkpoint-${taskId || 'latest'}-${timestamp}.bin`);
  } catch(err){
    console.error(err);
    echoAlert('Download failed: ' + (err.message||err));
  }
}

// IndexedDB helpers (main thread)
function openDb(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)){
        db.createObjectStore(STORE_NAME, {keyPath:'taskId'});
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error || new Error('IDB open failed'));
  });
}

async function inspectLatestCheckpoint(taskId){
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    if (taskId){
      const r = store.get(taskId);
      r.onsuccess = () => resolve(r.result || null);
      r.onerror = () => reject(r.error);
    } else {
      // iterate to find newest by timestamp
      const cur = store.openCursor();
      let best = null;
      cur.onsuccess = (e) => {
        const cursor = e.target.result;
        if (!cursor) { resolve(best); return; }
        const rec = cursor.value;
        if (!best || (rec.timestamp || 0) > (best.timestamp || 0)) best = rec;
        cursor.continue();
      }
      cur.onerror = () => reject(cur.error);
    }
  });
}

async function readCheckpointBlob(taskId){
  const rec = await inspectLatestCheckpoint(taskId);
  if (!rec) return null;
  // modelWeights stored as Blob in rec.modelWeights
  return rec.modelWeights || null;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 60000);
}

async function deleteCheckpoint(taskId){
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    if (taskId){
      const r = store.delete(taskId);
      r.onsuccess = ()=>resolve(true);
      r.onerror = ()=>reject(r.error);
    } else {
      // delete all
      const c = store.clear();
      c.onsuccess=()=>resolve(true);
      c.onerror=()=>reject(c.error);
    }
  });
}

// UI wiring
startBtn.onclick = ()=>{ startNewWorker(); }
resumeBtn.onclick = ()=>{ resumeFromCheckpoint(); }
pauseBtn.onclick = ()=>{ pauseWorker(); }
downloadBtn.onclick = ()=>{ downloadLatestCheckpoint(); }
clearBtn.onclick = async ()=> {
  const taskIdInput = document.getElementById('taskIdInput').value.trim();
  const id = taskIdInput || null;
  if (!confirm('Delete checkpoint for ' + (id||'ALL') + '?')) return;
  await deleteCheckpoint(id);
  inspectPre.textContent = 'Deleted checkpoint(s).';
  logStatus('Deleted checkpoint(s).');
}
inspectBtn.onclick = async ()=>{
  try{
    const taskIdInput = document.getElementById('taskIdInput').value.trim();
    const rec = await inspectLatestCheckpoint(taskIdInput || null);
    if (!rec) {
      inspectPre.textContent = 'No checkpoint found.';
      return;
    }
    const summary = {
      taskId: rec.taskId,
      timestamp: new Date(rec.timestamp).toLocaleString(),
      stepNumber: rec.stepNumber,
      taskConfig: rec.taskConfig,
      modelWeightsBytes: (rec.modelWeights && rec.modelWeights.size) ? rec.modelWeights.size : 'n/a'
    };
    inspectPre.textContent = JSON.stringify(summary, null, 2);
  }catch(err){
    inspectPre.textContent = 'Inspect failed: ' + (err.message||err);
  }
}

// On page load, create worker (but idle)
createWorker();
logStatus('Main thread ready.');

// Try to show if a checkpoint exists at load
(async ()=>{
  const recent = await inspectLatestCheckpoint(null);
  if (recent) {
    logStatus('Found existing checkpoint for taskId=' + recent.taskId + ' (step ' + recent.stepNumber + ')');
    inspectPre.textContent = JSON.stringify({
      taskId: recent.taskId,
      stepNumber: recent.stepNumber,
      timestamp: new Date(recent.timestamp).toLocaleString(),
      modelWeightsBytes: (recent.modelWeights && recent.modelWeights.size) ? recent.modelWeights.size : 'n/a'
    }, null, 2);
  } else {
    inspectPre.textContent = 'No checkpoint present in IndexedDB.';
  }
})();

</script>
</body>
</html>

