<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P2P Chat ‚Äî Serverless WebRTC (Demo)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<style>
/* (Same styling as your original ‚Äî omitted for brevity in this message)
   Paste your original CSS here or keep the stylesheet from your file.
   For readability the full CSS from your original file should be included. */
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;margin:0;display:flex;align-items:center;justify-content:center;padding:20px}
.container{background:#fff;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);max-width:600px;width:100%;overflow:hidden}
.header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:25px;text-align:center}
.header h1{font-size:24px;margin:0 0 5px}
.header p{font-size:13px;opacity:.95;margin:0}
.status{padding:15px 25px;background:#f8f9fa;border-bottom:1px solid #e9ecef;display:flex;align-items:center;justify-content:space-between}
.status-indicator{display:flex;align-items:center;gap:8px}
.status-dot{width:10px;height:10px;border-radius:50%;background:#dc3545;animation:pulse 2s infinite}
.status-dot.connected{background:#28a745;animation:none}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
.peer-id{font-size:11px;color:#6c757d;font-family:monospace}
.main-content{padding:25px}
.section{margin-bottom:25px}
.section h2{font-size:16px;margin-bottom:15px;color:#495057}
.button-group{display:flex;gap:10px;flex-wrap:wrap}
button{padding:12px 24px;border:none;border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;transition:all .3s;flex:1;min-width:140px}
button:disabled{opacity:.5;cursor:not-allowed}
.btn-primary{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff}
.btn-secondary{background:#6c757d;color:#fff}
.btn-success{background:#28a745;color:#fff}
input[type="text"],textarea{width:100%;padding:12px;border:2px solid #e9ecef;border-radius:10px;font-size:14px;transition:border-color .3s;margin-bottom:10px;font-family:monospace}
textarea{resize:vertical;min-height:80px}
.qr-container{text-align:center;padding:20px;background:#f8f9fa;border-radius:10px;margin-top:15px}
#qrcode{display:inline-block;padding:15px;background:#fff;border-radius:10px;margin-bottom:15px}
.connection-url{font-size:11px;word-break:break-all;background:#fff;padding:10px;border-radius:5px;margin-top:10px;font-family:monospace}
.chat-area{display:none;flex-direction:column;height:400px}
.chat-area.active{display:flex}
.messages{flex:1;overflow-y:auto;padding:20px;background:#f8f9fa;border-radius:10px;margin-bottom:15px}
.message{margin-bottom:15px;animation:slideIn .3s}
@keyframes slideIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.message.sent{text-align:right}
.message-bubble{display:inline-block;padding:10px 15px;border-radius:15px;max-width:70%;word-wrap:break-word}
.message.received .message-bubble{background:#fff;color:#212529;border-bottom-left-radius:5px}
.message.sent .message-bubble{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;border-bottom-right-radius:5px}
.message-time{font-size:10px;opacity:.6;margin-top:5px}
.message-input-area{display:flex;gap:10px}
.message-input-area input{margin-bottom:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif}
.hidden{display:none}
.setup-area{display:block}
.info-box{background:#e7f3ff;border-left:4px solid #667eea;padding:15px;border-radius:5px;font-size:13px;color:#495057;margin-bottom:20px}
.step-indicator{background:#f8f9fa;padding:15px;border-radius:10px;margin:15px 0;border-left:4px solid #28a745}
.code-box{background:#2d2d2d;color:#f8f8f2;padding:15px;border-radius:8px;font-family:monospace;font-size:12px;word-break:break-all;margin:10px 0;max-height:150px;overflow-y:auto}
.copy-ok{background:#d4edda;border-left:4px solid #28a745;padding:10px;border-radius:6px;margin-top:8px;color:#155724;font-size:13px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üîí P2P Secure Chat</h1>
    <p>Decentralized ‚Ä¢ No Servers ‚Ä¢ Private (demo)</p>
  </div>

  <div class="status">
    <div class="status-indicator">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    <div class="peer-id" id="peerId"></div>
  </div>

  <div class="main-content">
    <div class="setup-area" id="setupArea">
      <div class="info-box">
        ‚ÑπÔ∏è This demo uses WebRTC for direct P2P connections. Exchange codes (or scan QR) to pair. For higher reliability across networks you will need a TURN server.
      </div>

      <div class="section">
        <h2>Option 1: Start a New Chat Room</h2>
        <button class="btn-primary" id="createRoom">Create Room</button>

        <div id="hostInstructions" class="hidden">
          <div class="step-indicator">
            <h3>üì§ Step 1: Share Your Offer Code</h3>
            <p>Copy the code below and send it to your friend (Signal/WhatsApp/etc.), or have them scan the QR code.</p>
          </div>

          <div class="code-box" id="offerCode">‚Äî</div>
          <button class="btn-secondary" id="copyOffer">Copy Offer Code</button>

          <div class="qr-container">
            <p style="font-weight:600;margin-bottom:10px;">Or scan this QR code:</p>
            <div id="qrcode"></div>
          </div>

          <div class="step-indicator" style="margin-top:20px;">
            <h3>üì• Step 2: Paste Answer Code</h3>
            <p>Paste the answer code your friend sends you here:</p>
          </div>
          <textarea id="answerInput" placeholder="Paste the answer code from your friend here..."></textarea>
          <button class="btn-success" id="submitAnswer">Connect</button>
        </div>
      </div>

      <div class="section">
        <h2>Option 2: Join Existing Room</h2>
        <div class="step-indicator">
          <h3>üì• Paste Offer Code</h3>
          <p>Paste the offer code you received from your friend:</p>
        </div>
        <textarea id="joinInput" placeholder="Paste offer code here..."></textarea>
        <button class="btn-success" id="joinRoom">Join Room</button>

        <div id="joinerInstructions" class="hidden">
          <div class="warning-box" style="display:block;background:#fff3cd;border-left:4px solid #ffc107;padding:15px;border-radius:5px;font-size:13px;color:#495057;margin-bottom:20px">
            ‚ö†Ô∏è <strong>Important:</strong> Copy the answer code below and send it back to your friend. They need it to finish the connection.
          </div>

          <div class="code-box" id="answerCode">‚Äî</div>
          <button class="btn-secondary" id="copyAnswer">Copy Answer Code</button>

          <div class="step-indicator" style="margin-top:20px;">
            <h3>‚è≥ Waiting for Connection...</h3>
            <p>Once your friend pastes your answer code into their page, the connection will complete.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="chat-area" id="chatArea">
      <div class="messages" id="messages"></div>
      <div class="message-input-area" style="padding-top:8px">
        <input type="text" id="messageInput" placeholder="Type a message...">
        <button class="btn-primary" id="sendBtn">Send</button>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Serverless P2P Chat ‚Äî improved MVP
  How to test:
  - Open this page in two browser windows or devices.
  - On A: "Create Room" ‚Üí copy offer or QR.
  - On B: paste offer into join box ‚Üí "Join Room" ‚Üí copy answer.
  - On A: paste answer into answer textarea ‚Üí "Connect".
  - Chat should start.
*/

/* ========== Config ========== */
const config = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }
    // For better NAT traversal add a TURN server here.
  ]
};

/* ========== State ========== */
let pc = null;
let dataChannel = null;
let isInitiator = false;

/* ========== DOM ========= */
const createRoomBtn = document.getElementById('createRoom');
const joinRoomBtn = document.getElementById('joinRoom');
const submitAnswerBtn = document.getElementById('submitAnswer');
const joinInput = document.getElementById('joinInput');
const answerInput = document.getElementById('answerInput');
const hostInstructions = document.getElementById('hostInstructions');
const joinerInstructions = document.getElementById('joinerInstructions');
const offerCode = document.getElementById('offerCode');
const answerCode = document.getElementById('answerCode');
const copyOfferBtn = document.getElementById('copyOffer');
const copyAnswerBtn = document.getElementById('copyAnswer');
const setupArea = document.getElementById('setupArea');
const chatArea = document.getElementById('chatArea');
const messages = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const peerId = document.getElementById('peerId');

/* small peer id for UI */
const myPeerId = 'peer-' + Math.random().toString(36).slice(2,11);
peerId.textContent = myPeerId;

/* ========= Helpers ========= */
function updateStatus(state, text) {
  statusText.textContent = text;
  statusDot.className = 'status-dot';
  if (state === 'connected') statusDot.classList.add('connected');
}
function escapeHtml(s){ const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function scrollMessages(){ messages.scrollTop = messages.scrollHeight; }

/* Wait for ICE gathering. resolves when iceGatheringState === 'complete' or after timeout */
function waitForIceGathering(pc, timeout = 7000) {
  return new Promise((resolve) => {
    if (!pc) return resolve();
    if (pc.iceGatheringState === 'complete') return resolve();
    let done = false;
    const onState = () => {
      if (pc.iceGatheringState === 'complete' && !done) { done = true; pc.removeEventListener('icegatheringstatechange', onState); resolve(); }
    };
    pc.addEventListener('icegatheringstatechange', onState);
    // fallback in case gathering doesn't transition to 'complete' (some browsers)
    setTimeout(() => { if (!done) { done = true; pc.removeEventListener('icegatheringstatechange', onState); resolve(); } }, timeout);
  });
}

/* copy text helper + UX */
async function copyText(text, btn) {
  try {
    await navigator.clipboard.writeText(text);
    if (btn) {
      const original = btn.textContent;
      btn.textContent = '‚úì Copied!';
      setTimeout(() => btn.textContent = original, 2000);
    }
  } catch(e) {
    alert('Clipboard write failed: ' + e.message);
  }
}

/* show QR for offer URL */
function makeQRCode(offerData) {
  const qroot = document.getElementById('qrcode');
  qroot.innerHTML = '';
  try {
    const url = window.location.origin + window.location.pathname + '?offer=' + encodeURIComponent(offerData);
    new QRCode(qroot, { text: url, width: 180, height: 180 });
  } catch (e) {
    qroot.innerHTML = 'QR generation failed';
  }
}

/* UI message append */
function addMessage(text, isSent=false, time=null) {
  const div = document.createElement('div');
  div.className = 'message ' + (isSent ? 'sent' : 'received');
  const when = time || new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  div.innerHTML = `<div class="message-bubble">${escapeHtml(text)}<div class="message-time">${when}</div></div>`;
  messages.appendChild(div);
  scrollMessages();
}

/* safe JSON encode/decode for base64 */
function encodeOffer(obj){ return btoa(unescape(encodeURIComponent(JSON.stringify(obj)))); }
function decodeOffer(s){ return JSON.parse(decodeURIComponent(escape(atob(s)))); }

/* ========== WebRTC logic ========= */
async function initializePeerConnection() {
  pc = new RTCPeerConnection(config);

  pc.onicecandidate = (ev) => {
    console.log('onicecandidate', !!ev.candidate);
  };

  pc.oniceconnectionstatechange = () => {
    console.log('iceConnectionState', pc.iceConnectionState);
    if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
      updateStatus('disconnected', 'Disconnected');
      alert('Connection failed or disconnected. Refresh to try again.');
    }
  };

  pc.onconnectionstatechange = () => {
    console.log('connectionState', pc.connectionState);
    if (pc.connectionState === 'connected') {
      updateStatus('connected', 'Connected & Encrypted');
      setupArea.classList.add('hidden');
      chatArea.classList.add('active');
      messageInput.focus();
    } else if (pc.connectionState === 'connecting') {
      updateStatus('waiting', 'Connecting...');
    }
  };

  // dataChannel will be created by initiator; joiner will get it via ondatachannel
  pc.ondatachannel = (ev) => {
    console.log('ondatachannel', ev.channel);
    dataChannel = ev.channel;
    setupDataChannel();
  };
}

function setupDataChannel() {
  if (!dataChannel) return;
  console.log('setupDataChannel', dataChannel.readyState);

  dataChannel.onopen = () => {
    console.log('DataChannel open');
    updateStatus('connected', 'Connected & Encrypted');
    setupArea.classList.add('hidden');
    chatArea.classList.add('active');
    messageInput.focus();
  };

  dataChannel.onclose = () => {
    console.log('DataChannel closed');
    updateStatus('disconnected', 'Disconnected');
    alert('Connection closed. Refresh to start a new session.');
  };

  dataChannel.onerror = (err) => {
    console.error('DataChannel error', err);
  };

  dataChannel.onmessage = (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      addMessage(msg.text, false, msg.time);
    } catch (e) {
      // fallback if sender doesn't use structured JSON
      addMessage(ev.data, false);
    }
  };
}

/* Host: create offer and show base64 offer */
createRoomBtn.addEventListener('click', async () => {
  isInitiator = true;
  createRoomBtn.disabled = true;
  updateStatus('waiting', 'Creating room...');
  await initializePeerConnection();

  // create data channel
  dataChannel = pc.createDataChannel('chat');
  setupDataChannel();

  try {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // Wait for ICE
    await waitForIceGathering(pc, 8000);

    // localDescription may contain gathered ICE candidates in the sdp
    const localDesc = pc.localDescription;
    const payload = { type: localDesc.type || 'offer', sdp: localDesc.sdp };
    const offerData = encodeOffer(payload);

    offerCode.textContent = offerData;
    hostInstructions.classList.remove('hidden');

    // generate QR with URL containing the offer base64 (URL-encoded)
    makeQRCode(offerData);

    updateStatus('waiting', 'Waiting for peer to join...');
  } catch (e) {
    console.error(e);
    alert('Failed to create offer: ' + e.message);
    createRoomBtn.disabled = false;
  }
});

/* Copy offer */
copyOfferBtn.addEventListener('click', () => copyText(offerCode.textContent, copyOfferBtn));

/* Joiner: join room from offer */
joinRoomBtn.addEventListener('click', async () => {
  const raw = joinInput.value.trim();
  if (!raw) return alert('Please paste the offer code you received.');

  try {
    const payload = decodeOffer(raw);

    isInitiator = false;
    joinRoomBtn.disabled = true;
    updateStatus('waiting', 'Joining room...');
    await initializePeerConnection();

    // set remote offer
    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: payload.sdp }));

    // create answer
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // wait for ICE gathering
    await waitForIceGathering(pc, 8000);

    const localDesc = pc.localDescription;
    const answerPayload = { type: localDesc.type || 'answer', sdp: localDesc.sdp };
    const answerData = encodeOffer(answerPayload);

    answerCode.textContent = answerData;
    joinerInstructions.classList.remove('hidden');
    updateStatus('waiting', 'Answer generated ‚Äî send it to host.');

    // show a small copy success area
  } catch (e) {
    console.error(e);
    alert('Invalid offer code or failed to join: ' + (e.message || e));
    joinRoomBtn.disabled = false;
  }
});

/* Copy answer */
copyAnswerBtn.addEventListener('click', () => copyText(answerCode.textContent, copyAnswerBtn));

/* Host pastes answer from joiner */
submitAnswerBtn.addEventListener('click', async () => {
  const raw = answerInput.value.trim();
  if (!raw) return alert('Please paste the answer code your friend sent you.');

  try {
    const payload = decodeOffer(raw);
    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: payload.sdp }));
    submitAnswerBtn.disabled = true;
    updateStatus('waiting', 'Finalizing connection...');
  } catch (e) {
    console.error(e);
    alert('Invalid answer code or error applying it: ' + e.message);
  }
});

/* Send message */
function sendMessage() {
  const text = messageInput.value.trim();
  if (!text) return;
  if (!dataChannel || dataChannel.readyState !== 'open') {
    alert('No connection yet. Wait for the other peer.');
    return;
  }
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  const payload = { text, time };
  dataChannel.send(JSON.stringify(payload));
  addMessage(text, true, time);
  messageInput.value = '';
}
sendBtn.addEventListener('click', sendMessage);
messageInput.addEventListener('keypress', (e)=>{
  if (e.key === 'Enter') sendMessage();
});

/* On load: if ?offer=... is present, populate join input for scanning QR flow */
window.addEventListener('load', () => {
  const params = new URLSearchParams(window.location.search);
  const offerParam = params.get('offer');
  if (offerParam) {
    try {
      // offerParam might be encoded already via encodeURIComponent
      const decoded = decodeURIComponent(offerParam);
      joinInput.value = decoded;
      joinInput.scrollIntoView({behavior:'smooth'});
    } catch(e) {
      console.warn('Could not prefill offer param', e);
    }
  }
});
</script>
</body>
</html>
