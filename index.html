<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIY LLM Toolkit | Modular Prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Phase 3/4 Libraries: TensorFlow.js and Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    
    <style>
        /* --- Google Cloud/Material Design Variables --- */
        :root {
            --primary-blue: #1A73E8; /* Deep Google Blue */
            --header-blue: #1A2E44; /* Darker blue for a professional app bar */
            --nav-panel-color: #F1F3F4;
            --active-item-color: #E8F0FE;
            --surface-color: #FFFFFF;
            --background-color: #F8F9FA;
            --text-color: #202124;
            --secondary-text: #5F6368;
            --border-color: #DADCE0;
            --google-red: #DB4437;
            --google-green: #0F9D58;
            --elevation-low: 0 1px 2px 0 rgba(0,0,0,0.1), 0 1px 3px 0 rgba(0,0,0,0.06);
            --elevation-mid: 0 2px 4px 0 rgba(0,0,0,0.1), 0 2px 5px 0 rgba(0,0,0,0.08);
        }

        /* --- Base Layout --- */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .top-header {
            background-color: var(--header-blue);
            color: var(--surface-color);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            box-shadow: var(--elevation-low);
            z-index: 10;
        }
        .top-header h1 { font-size: 1.5em; font-weight: 400; margin: 0 30px 0 10px; white-space: nowrap; }
        .top-header h1 i { color: #4285F4; margin-right: 8px; }
        .main-content-area { display: flex; flex-grow: 1; }
        .side-nav {
            width: 250px;
            background-color: var(--surface-color);
            border-right: 1px solid var(--border-color);
            padding: 15px 0;
            flex-shrink: 0;
        }
        .nav-item { padding: 10px 20px; color: var(--secondary-text); font-size: 0.95em; cursor: pointer; transition: background-color 0.2s; }
        .nav-item.active { background-color: var(--active-item-color); color: var(--primary-blue); border-left: 3px solid var(--primary-blue); font-weight: 500; padding-left: 17px; }
        .nav-item i { margin-right: 12px; font-size: 1.1em; width: 20px; text-align: center; }
        .content-wrapper { flex-grow: 1; padding: 30px; max-width: 1000px; }
        h2 { color: var(--text-color); font-weight: 500; font-size: 1.6em; margin-top: 0; margin-bottom: 20px; }
        .divider { margin: 30px 0; border: none; border-top: 1px solid var(--border-color); }
        
        /* Model Mode Toggle */
        .mode-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--elevation-low);
            border-left: 4px solid var(--primary-blue);
        }
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--google-green); }
        input:checked + .slider:before { transform: translateX(26px); }
        .mode-label { font-weight: 500; margin-right: 15px; color: var(--primary-blue); }
        .mode-label span { color: var(--secondary-text); font-weight: 400; font-size: 0.9em;}
        
        /* Model Controls Panel (Phase 4) */
        #model-controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: var(--elevation-low);
            margin-bottom: 20px;
        }
        .control-group label { display: block; font-size: 0.85em; color: var(--secondary-text); margin-bottom: 5px; }
        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
            color: var(--text-color);
        }
        
        /* Dashboard (Phase 4) */
        #model-dashboard {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        #chart-container {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--elevation-low);
        }
        #metrics-panel {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--elevation-low);
            border-left: 4px solid var(--google-green);
        }
        #metrics-panel h3 { margin-top: 0; color: var(--google-green); font-weight: 500; font-size: 1.2em; }
        .metric-item { margin-bottom: 10px; font-size: 0.95em; }
        .metric-item strong { display: block; font-size: 1.1em; color: var(--text-color); }
        
        /* NEW: Data Analytics Dashboard */
        #data-analytics-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .dashboard-card {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--elevation-low);
        }
        .dashboard-card h3 { 
            margin-top: 0; 
            font-size: 1.2em; 
            color: var(--primary-blue);
        }

        /* NEW: Heatmap specific styles */
        #transition-heatmap-content {
            overflow-x: auto;
            max-height: 350px;
        }
        #transition-heatmap-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75em;
            table-layout: fixed;
        }
        #transition-heatmap-content th, #transition-heatmap-content td {
            border: 1px solid #eee;
            padding: 5px;
            text-align: center;
            transition: background-color 0.3s;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            height: 30px;
        }
        #transition-heatmap-content th {
            background-color: #f7f7f7;
            font-weight: 500;
        }
        .heatmap-cell {
            cursor: default;
            color: white; /* Text color will be white over colored background */
            font-weight: 500;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }
        
        /* Re-used Component Styles (from previous step) */
        .data-source-card, #matrix-output { background-color: var(--surface-color); border-radius: 8px; box-shadow: var(--elevation-low); padding: 20px; transition: box-shadow 0.3s; }
        .data-source-tabs { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        .data-source-card { flex: 1 1 300px; text-align: center; cursor: pointer; }
        .data-source-card:hover { box-shadow: var(--elevation-mid); }
        button { background-color: var(--primary-blue); color: var(--surface-color); border: none; padding: 10px 20px; font-size: 14px; font-weight: 500; text-transform: capitalize; cursor: pointer; border-radius: 4px; transition: background-color 0.3s, box-shadow 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        button:hover { background-color: #3B7DD1; box-shadow: 0 2px 4px rgba(0,0,0,0.15); }
        textarea { border: 1px solid var(--border-color); border-radius: 4px; padding: 12px; height: 120px; margin-bottom: 20px; width: 100%; box-sizing: border-box; font-family: 'Roboto', sans-serif; font-size: 1em; color: var(--text-color); background-color: var(--surface-color); }
        .upload-container { border: 2px dashed var(--border-color); background-color: var(--surface-color); border-radius: 8px; padding: 30px; text-align: center; margin-top: 20px; transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s; cursor: pointer; position: relative; }
        .upload-container:hover { border-color: var(--primary-blue); background-color: #F8F9FA; box-shadow: var(--elevation-low); }
        .upload-container.drag-over { background-color: #E8F0FE; border-color: var(--primary-blue); box-shadow: 0 0 0 3px rgba(26,115,232,0.2); }
        .upload-container i.fa-file-import { font-size: 3em; color: var(--primary-blue); margin-bottom: 15px; display: block; }
        #file-analytics-card { margin-top: 20px; background-color: var(--surface-color); border-radius: 8px; box-shadow: var(--elevation-low); padding: 20px; border-left: 4px solid var(--google-green); }
        .progress-bar-container { width: 100%; background-color: #eee; border-radius: 4px; margin-top: 15px; overflow: hidden; display: none; align-items: center; height: 35px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); position: relative; }
        #llm-output { padding: 20px; border: 1px solid var(--border-color); background-color: #F1F3F4; margin-top: 20px; color: var(--text-color); line-height: 1.6; }
        .progress-bar { height: 100%; background-color: var(--primary-blue); width: 0%; text-align: center; line-height: 35px; color: white; font-size: 12px; transition: width 0.3s ease-out; border-radius: 4px 0 0 4px; white-space: nowrap; overflow: hidden; padding: 0 10px; box-sizing: border-box; }
        .progress-bar-container button { position: absolute; right: 5px; top: 50%; transform: translateY(-50%); z-index: 2; background-color: var(--google-red); padding: 5px 10px; font-size: 0.8em; box-shadow: none; margin-left: auto; }
        #file-preview { display: flex; flex-wrap: wrap; justify-content: flex-start; gap: 10px; margin-top: 20px; padding-top: 15px; border-top: 1px dashed var(--border-color); }
        .file-item { background-color: #F1F3F4; border: 1px solid #DADCE0; border-radius: 16px; padding: 6px 12px; font-size: 0.85em; white-space: nowrap; color: var(--secondary-text); display: flex; align-items: center; gap: 6px; transition: background-color 0.2s, box-shadow 0.2s; cursor: default; }
        .file-item:hover { background-color: #E8F0FE; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .file-item i.fa-file-alt { color: var(--primary-blue); }
        .file-item .remove-file { color: var(--secondary-text); cursor: pointer; font-size: 0.9em; margin-left: 5px; transition: color 0.2s; }
        .file-item .remove-file:hover { color: var(--google-red); }

    </style>
</head>
<body>
<!-- Top Header Bar (Google Cloud Style) -->
<div class="top-header">
    <i class="fas fa-bars" style="margin-right: 20px; font-size: 1.2em;"></i>
    <h1><i class="fas fa-brain"></i> DIY LLM Toolkit</h1>
    <div class="top-header-search">
        <i class="fas fa-search"></i>
        Search the Knowledge Base...
    </div>
    <i class="fas fa-question-circle" style="margin-left: auto; margin-right: 15px; color: rgba(255, 255, 255, 0.7);"></i>
    <i class="fas fa-bell" style="margin-right: 15px; color: rgba(255, 255, 255, 0.7);"></i>
    <div style="width: 30px; height: 30px; background-color: #A0C3FF; border-radius: 50%;"></div>
</div>

<div class="main-content-area">
    <div class="side-nav">
        <div class="nav-item"> <i class="fas fa-home"></i> Overview </div>
        <div class="nav-item active"> <i class="fas fa-database"></i> Data & Tokenization </div>
        <div class="nav-item"> <i class="fas fa-chart-line"></i> Analytics & Metrics </div>
        <div class="nav-item"> <i class="fas fa-cogs"></i> Model Training </div>
        <div class="nav-item"> <i class="fas fa-robot"></i> Text Generation </div>
    </div>

    <div class="content-wrapper">
        <p style="font-size: 0.95em; margin-bottom: 25px;">A modular prototype for training lightweight LLMs, supporting Markov chain fallback and TensorFlow-based attention simulation.</p>

        <!-- Phase 4: Model Mode Toggle -->
        <div class="mode-toggle">
            <div class="mode-label" id="current-mode-label">
                Current Mode: <strong id="model-mode-name">Markov Chain (Fallback)</strong>
                <br><span>(Switch to Transformer for vector-based generation)</span>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="model-mode-toggle" onchange="toggleModelMode(this.checked)">
                <span class="slider"></span>
            </label>
        </div>

        <section id="data-ingestion-section">
            <h2>Data Ingestion & Tokenization</h2>
            
            <!-- Data Sources (Unchanged) -->
            <div class="data-source-tabs">
                <div class="data-source-card">
                    <h3>Local Files</h3>
                    <i class="fas fa-upload" style="color: var(--primary-blue); font-size: 2.5em; margin-bottom: 16px;"></i>
                    <p style="font-size: 0.9em;">Drag, drop, or select multiple local files for instant processing.</p>
                    <label class="upload-label" for="file-input">Select Local Files</label>
                </div>
                <div class="data-source-card" onclick="connectAwsS3()">
                    <h3>AWS S3 Storage</h3>
                    <i class="fab fa-aws" style="color: #FF9900; font-size: 2.5em; margin-bottom: 16px;"></i>
                    <p style="font-size: 0.9em; font-weight: 500;">Connect to an AWS S3 bucket to stream training data.</p>
                    <button style="background-color: #FF9900;">
                        <i class="fas fa-link"></i> Connect S3 Bucket
                    </button>
                </div>
                <div class="data-source-card">
                    <h3>Kaggle Dataset</h3>
                    <i class="fas fa-cloud-download-alt" style="color: var(--google-green); font-size: 2.5em; margin-bottom: 16px;"></i>
                    <p style="font-size: 0.9em;">Pull data directly from a public Kaggle dataset via API.</p>
                    <button onclick="showAlert('Integration logic for Kaggle data pull goes here.')" style="background-color: var(--google-green);">
                        <i class="fas fa-download"></i> Fetch from Kaggle
                    </button>
                </div>
            </div>

            <!-- Drop Zone (Unchanged) -->
            <div class="upload-container" id="drop-zone">
                 <i class="fas fa-file-import"></i>
                 <p>Drop files here or paste below to train the model.</p>
                 <input type="file" id="file-input" multiple accept=".txt,.csv,.md">
            </div>

            <div id="file-analytics-card">
                <h3>Uploaded Files Overview</h3>
                <div id="file-analytics-summary">0 Files Uploaded (0.0 MB)</div>
                <div id="progress-container" class="progress-bar-container">
                    <div id="progress-bar" class="progress-bar">0%</div>
                    <button onclick="cancelStreaming()"><i class="fas fa-times"></i> Cancel</button>
                </div>
                <div id="file-preview"></div>
                <div style="margin-top: 15px;">
                    <button onclick="tokenizer.exportVocabulary()" style="background-color: #5F6368;"><i class="fas fa-download"></i> Export Vocab</button>
                </div>
            </div>

            <textarea id="text-input" placeholder="... or paste your text corpus directly here."></textarea>
            
            <div style="display: flex; gap: 15px; justify-content: flex-start; margin-bottom: 30px;">
                <button onclick="dataHandler.tokenizeAndBuildMatrix()"><i class="fas fa-list-ol"></i> Tokenize & Preprocess</button>
                <button onclick="miniTransformer.trainOnText(document.getElementById('text-input').value, 5, 32)" style="background-color: #3C769D;"><i class="fas fa-bolt"></i> Train Model (Mock)</button>
            </div>
            
        </section>

        <hr class="divider">

        <!-- NEW: Data Analytics Section (Visualizes Tokenization) -->
        <section id="data-analytics-section" style="display: none;">
            <h2>Data Analytics & Visualization</h2>
            <p style="font-size: 0.9em; margin-bottom: 25px;">These charts update after running the "Tokenize & Preprocess" step.</p>
            <div id="data-analytics-dashboard">
                <div id="token-chart-container" class="dashboard-card">
                    <h3><i class="fas fa-chart-bar"></i> Top 10 Token Frequency</h3>
                    <canvas id="tokenChart"></canvas>
                </div>
                <div id="heatmap-container" class="dashboard-card">
                    <h3><i class="fas fa-th-large"></i> Transition/Attention Heatmap</h3>
                    <div id="transition-heatmap-content">
                        <em>Run tokenization to view Markov transition probabilities.</em>
                    </div>
                </div>
            </div>
            <hr class="divider">
        </section>


        <section id="model-section">
            <h2>Model Configuration & Execution</h2>

            <!-- Phase 4: Model Controls Panel -->
            <div id="model-controls-panel">
                <div class="control-group">
                    <label for="max-tokens-input">Max Tokens (Inference)</label>
                    <input type="number" id="max-tokens-input" value="500" min="10">
                </div>
                <div class="control-group">
                    <label for="temperature-input">Temperature (Sampling)</label>
                    <input type="number" id="temperature-input" value="0.8" step="0.1" min="0.1" max="2.0">
                </div>
                <div class="control-group">
                    <label for="embedding-size-input">Embedding Dim (d_model)</label>
                    <input type="number" id="embedding-size-input" value="64" min="16">
                </div>
                <div class="control-group">
                    <label for="epochs-input">Epochs (Training)</label>
                    <input type="number" id="epochs-input" value="10" min="1">
                </div>
                <div class="control-group">
                    <label for="batch-size-input">Batch Size (Training)</label>
                    <input type="number" id="batch-size-input" value="32" min="1">
                </div>
                <div class="control-group">
                    <label for="learning-rate-input">Learning Rate</label>
                    <input type="number" id="learning-rate-input" value="0.001" step="0.0001" min="0.0001">
                </div>
            </div>
            
            <!-- Phase 4: Model Monitor Dashboard -->
            <div id="model-dashboard">
                <div id="chart-container">
                    <h3><i class="fas fa-chart-area"></i> Live Loss Curve</h3>
                    <canvas id="lossChart"></canvas>
                </div>
                <div id="metrics-panel">
                    <h3><i class="fas fa-tachometer-alt"></i> Model Metrics</h3>
                    <div class="metric-item">Current Loss: <strong id="metric-loss">N/A</strong></div>
                    <div class="metric-item">Epochs Run: <strong id="metric-epochs">0</strong></div>
                    <div class="metric-item">Vocab Size: <strong id="metric-vocab-size">0</strong></div>
                    <div class="metric-item">Inference Latency: <strong id="metric-latency">N/A</strong></div>
                    <div class="metric-item">Memory Footprint: <strong id="metric-memory">0 MB</strong></div>
                    <button onclick="miniTransformer.saveModel()" style="margin-top: 15px;"><i class="fas fa-save"></i> Save Model Weights</button>
                    <button onclick="miniTransformer.loadModel()" style="margin-top: 10px; background-color: #5F6368;"><i class="fas fa-file-upload"></i> Load Model Weights</button>
                </div>
            </div>

        </section>

        <hr class="divider">

        <section id="generation-section">
            <h2>Text Generation</h2>
            <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                <input type="text" id="prompt-input" placeholder="Enter your prompt word or sentence here..." style="flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px;">
                <button onclick="generateTextFromModel()"><i class="fas fa-magic"></i> Generate Text</button>
            </div>
            
            <div id="llm-output">
                <em>Generated text will appear here. Start by tokenizing and training your model.</em>
            </div>
        </section>
    </div>
</div>

<!-- Modal for custom alerts (Replaces alert()) -->
<div id="custom-alert" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 1000;">
    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: var(--elevation-mid); max-width: 400px;">
        <h3 id="alert-title" style="margin-top: 0; color: var(--primary-blue);">Alert</h3>
        <p id="alert-message"></p>
        <button onclick="document.getElementById('custom-alert').style.display='none'" style="float: right;">OK</button>
    </div>
</div>

<script>
    // #region Phase 1: Modular Architecture & Config (config.json, app.js, utils.js)

    const CONFIG = {
        modelMode: 'MARKOV', // 'MARKOV' or 'TRANSFORMER'
        maxTokens: 500,
        temperature: 0.8,
        embeddingDim: 64,
        train: {
            epochs: 10,
            batchSize: 32,
            learningRate: 0.001
        }
    };

    let lossChart = null;
    let tokenChart = null;
    let currentStreamController = null;

    // --- Utility Functions (utils.js) ---

    function showAlert(message, title = 'Notification') {
        document.getElementById('alert-title').textContent = title;
        document.getElementById('alert-message').innerHTML = message;
        document.getElementById('custom-alert').style.display = 'flex';
    }

    /**
     * Initializes the loss chart (Line Chart for Training Metrics).
     */
    function initializeLossChart() {
        const ctx = document.getElementById('lossChart').getContext('2d');
        if (lossChart) lossChart.destroy();
        lossChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Training Loss',
                    data: [],
                    borderColor: 'rgb(26, 115, 232)',
                    backgroundColor: 'rgba(26, 115, 232, 0.1)',
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, title: { display: true, text: 'Loss' } },
                    x: { title: { display: true, text: 'Batch / Step' } }
                }
            }
        });
    }
    
    /**
     * Initializes the token chart (Bar Chart for Data Analysis).
     */
    function initializeTokenChart() {
        const ctx = document.getElementById('tokenChart').getContext('2d');
        if (tokenChart) tokenChart.destroy();
        tokenChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Token Count',
                    data: [],
                    backgroundColor: 'rgba(15, 157, 88, 0.6)', // Google Green
                    borderColor: 'rgb(15, 157, 88)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                indexAxis: 'y', // Horizontal bars
                scales: {
                    x: { beginAtZero: true, title: { display: true, text: 'Frequency' } },
                    y: { ticks: { autoSkip: false } }
                }
            }
        });
    }

    // --- Event System (Lightweight Observer Pattern) ---
    const state = new Proxy({
        mode: CONFIG.modelMode,
        vocabSize: 0,
        currentLoss: 'N/A',
        epochsRun: 0,
        latency: 'N/A'
    }, {
        set(obj, prop, value) {
            obj[prop] = value;
            updateUI(prop, value);
            return true;
        }
    });

    /**
     * Updates UI elements based on state changes.
     */
    function updateUI(prop, value) {
        switch (prop) {
            case 'mode':
                document.getElementById('model-mode-name').textContent = value === 'MARKOV' ? 'Markov Chain (Fallback)' : 'MiniTransformer (TF.js)';
                document.getElementById('current-mode-label').style.borderLeftColor = value === 'MARKOV' ? '#ccc' : 'var(--primary-blue)';
                document.getElementById('llm-output').innerHTML = `<em>Switched to ${value} mode. Re-run generation.</em>`;
                break;
            case 'vocabSize':
                document.getElementById('metric-vocab-size').textContent = value.toLocaleString();
                break;
            case 'currentLoss':
                document.getElementById('metric-loss').textContent = typeof value === 'number' ? value.toFixed(4) : value;
                break;
            case 'epochsRun':
                document.getElementById('metric-epochs').textContent = value.toLocaleString();
                break;
            case 'latency':
                document.getElementById('metric-latency').textContent = value;
                break;
            default:
                break;
        }
    }

    function toggleModelMode(isChecked) {
        state.mode = isChecked ? 'TRANSFORMER' : 'MARKOV';
        // Hide/Show training controls based on mode
        const displayStyle = state.mode === 'TRANSFORMER' ? 'grid' : 'none';
        document.getElementById('model-controls-panel').style.display = displayStyle;
        document.getElementById('model-dashboard').style.display = displayStyle;
        
        // If switching to TRANSFORMER, ensure chart is initialized
        if (state.mode === 'TRANSFORMER' && !lossChart) {
             initializeLossChart();
        }
    }
    
    // --- UI Controls Synchronization ---
    document.getElementById('max-tokens-input').addEventListener('input', (e) => CONFIG.maxTokens = parseInt(e.target.value));
    document.getElementById('temperature-input').addEventListener('input', (e) => CONFIG.temperature = parseFloat(e.target.value));
    document.getElementById('embedding-size-input').addEventListener('input', (e) => CONFIG.embeddingDim = parseInt(e.target.value));
    document.getElementById('epochs-input').addEventListener('input', (e) => CONFIG.train.epochs = parseInt(e.target.value));
    document.getElementById('batch-size-input').addEventListener('input', (e) => CONFIG.train.batchSize = parseInt(e.target.value));
    document.getElementById('learning-rate-input').addEventListener('input', (e) => CONFIG.train.learningRate = parseFloat(e.target.value));


    // #endregion Phase 1

    // #region Phase 2: Data Preprocessing & Tokenization (dataHandler.js, tokenizer.js)

    /**
     * Phase 2 Deliverable: Placeholder Byte-Pair Encoding (BPE) or WordPiece Tokenizer.
     */
    class Tokenizer {
        constructor() {
            this.vocab = {}; 
            this.idToToken = {};
            this.tokenCounts = {}; // NEW: Store token frequencies
            this.nextId = 1;
        }

        /**
         * Cleans text (lower, punctuation removal)
         */
        cleanText(text) {
            // Lowercase and remove punctuation except for spaces
            return text.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
        }

        /**
         * Builds the vocabulary and token frequencies from the corpus (Mock BPE training)
         */
        train(corpus) {
            const cleanedCorpus = this.cleanText(corpus);
            const words = cleanedCorpus.split(/\s+/).filter(w => w.length > 0);
            
            // Reset state
            this.vocab = {};
            this.idToToken = {};
            this.tokenCounts = {};
            this.nextId = 1;

            words.forEach(word => {
                if (!this.vocab[word]) {
                    this.vocab[word] = this.nextId;
                    this.idToToken[this.nextId] = word;
                    this.nextId++;
                }
                this.tokenCounts[word] = (this.tokenCounts[word] || 0) + 1;
            });

            state.vocabSize = Object.keys(this.vocab).length;
            showAlert(`Mock Tokenizer trained. Vocab size: ${state.vocabSize}`, 'Tokenization Complete');
        }

        /**
         * Encodes text into an array of token IDs. (Tokenizer API Deliverable)
         */
        encode(text) {
            if (state.vocabSize === 0) return [];
            const cleanedText = this.cleanText(text);
            const words = cleanedText.split(/\s+/).filter(w => w.length > 0);
            return words.map(word => this.vocab[word] || this.vocab[' ']).filter(id => id);
        }

        /**
         * Decodes an array of token IDs into a string. (Tokenizer API Deliverable)
         */
        decode(token_ids) {
            return token_ids.map(id => this.idToToken[id] || '[UNK]').join(' ');
        }
        
        /**
         * Exports the vocabulary as a JSON file.
         */
        exportVocabulary() {
            const vocabJson = JSON.stringify(this.vocab, null, 2);
            const blob = new Blob([vocabJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'vocab.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showAlert('Vocabulary exported as <strong>vocab.json</strong>.', 'Export Successful');
        }
    }

    /**
     * Phase 2 Deliverable: Data Ingestion and Preprocessing Class
     */
    class DataHandler {
        constructor(tokenizer) {
            this.tokenizer = tokenizer;
            this.allUploadedFiles = [];
            this.textArea = document.getElementById('text-input');
            this.markovMatrix = {};
        }

        tokenizeAndBuildMatrix() {
            const corpus = this.textArea.value.trim();
            if (!corpus) {
                showAlert('Please provide text data before tokenizing.', 'Input Required');
                return;
            }
            
            // 1. Train/Update Tokenizer (Calculates counts)
            this.tokenizer.train(corpus);
            
            // 2. Build Markov Matrix 
            this.markovMatrix = this._buildMarkovMatrix(corpus);

            // 3. Update Visualizations (NEW)
            this.renderTokenChart(this.tokenizer.tokenCounts);
            this.renderTransitionHeatmap(this.markovMatrix);
            document.getElementById('data-analytics-section').style.display = 'block';

            // 4. Update Analytics
            document.getElementById('file-analytics-card').style.borderLeft = '4px solid var(--primary-blue)';
            document.getElementById('file-analytics-card').querySelector('h3').textContent = 'Processing Complete';
        }
        
        // NEW: Renders the bar chart for token frequencies
        renderTokenChart(tokenCounts) {
            initializeTokenChart();
            
            const sortedTokens = Object.entries(tokenCounts)
                .sort(([, countA], [, countB]) => countB - countA)
                .slice(0, 10); // Top 10

            tokenChart.data.labels = sortedTokens.map(([token]) => token);
            tokenChart.data.datasets[0].data = sortedTokens.map(([, count]) => count);
            tokenChart.update();
        }

        // NEW: Renders the heatmap for Markov transition probabilities
        renderTransitionHeatmap(matrix, limit = 5) {
            const container = document.getElementById('transition-heatmap-content');
            
            // Get the 'limit' most frequent starting words (keys in the matrix)
            const topWords = Object.entries(this.tokenizer.tokenCounts)
                                .sort(([, a], [, b]) => b - a)
                                .slice(0, limit)
                                .map(([word]) => word);
            
            if (topWords.length < 2) {
                container.innerHTML = `<em>Not enough unique tokens (${topWords.length}) to generate a meaningful transition map.</em>`;
                return;
            }

            let html = '<table><thead><tr><th>&rarr;</th>';
            // Header row (following words)
            topWords.forEach(word => {
                html += `<th>${word}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Body rows (starting words)
            topWords.forEach(startWord => {
                html += `<tr><th>${startWord}</th>`;
                topWords.forEach(nextWord => {
                    const counts = matrix[startWord] || {};
                    const totalTransitions = Object.values(counts).reduce((a, b) => a + b, 0);
                    const count = counts[nextWord] || 0;
                    const probability = totalTransitions > 0 ? (count / totalTransitions) : 0;
                    
                    // Convert probability (0 to 1) to a hue (e.g., green scale)
                    // HSL (0, 100%, 50%) is red, HSL (120, 100%, 50%) is green.
                    // We will use a blue/white scale for professionalism
                    const alpha = probability * 0.9 + 0.1; // Ensure background is visible
                    const color = `rgba(26, 115, 232, ${alpha})`; // Blue/Primary color scale
                    const text = probability.toFixed(2);
                    
                    html += `<td class="heatmap-cell" style="background-color: ${color};" title="P('${startWord}' -> '${nextWord}') = ${text}">
                                ${text}
                            </td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }


        // Old Markov function, now internal and moved to DataHandler
        _buildMarkovMatrix(text) {
            const words = this.tokenizer.cleanText(text).split(/\s+/).filter(w => w.length > 0);
            let matrix = {};
            for (let i = 0; i < words.length - 1; i++) {
                const current = words[i];
                const next = words[i + 1];
                if (!matrix[current]) matrix[current] = {};
                matrix[current][next] = (matrix[current][next] || 0) + 1;
            }
            return matrix;
        }

        // --- File/Streaming Handlers (Kept from previous step) ---
        updateFileAnalyticsSummary() {
            const totalSize = this.allUploadedFiles.reduce((sum, file) => sum + (file.size || 0), 0);
            const sizeInMB = (totalSize / 1048576).toFixed(2);
            document.getElementById('file-analytics-summary').innerHTML = `<strong>${this.allUploadedFiles.length}</strong> Files Uploaded (${sizeInMB} MB)`;
        }

        renderFilePreviews() {
            filePreview.innerHTML = '';
            this.allUploadedFiles.forEach((file, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.classList.add('file-item');
                const sizeDisplay = (file.size || 0) > 1048576 
                                    ? `${((file.size || 0) / 1048576).toFixed(2)} MB` 
                                    : `${((file.size || 0) / 1024).toFixed(1)} KB`;
                fileDiv.innerHTML = `<i class="far fa-file-alt"></i> <span><strong>${file.name}</strong> (${sizeDisplay})</span> <i class="fas fa-times remove-file" data-index="${index}"></i>`;
                filePreview.appendChild(fileDiv);
            });
            this.updateFileAnalyticsSummary();
        }
        
        removeFile(index) {
            if (index > -1 && index < this.allUploadedFiles.length) {
                const removedFile = this.allUploadedFiles.splice(index, 1)[0];
                if (this.allUploadedFiles.length === 0) {
                    this.textArea.value = '';
                } else {
                     showAlert(`File "<strong>${removedFile.name}</strong>" removed. For accurate content, please clear the textarea and re-upload remaining files, or manually edit the text.`, 'File Removed');
                }
                this.renderFilePreviews();
            }
        }

        async handleFiles(files) {
            if (!files.length) return;

            let totalNewSize = 0;
            let allText = '';
            
            for (const file of files) {
                if (!this.allUploadedFiles.some(f => f.name === file.name && f.size === file.size)) {
                    this.allUploadedFiles.push(file); 
                    totalNewSize += file.size;
                    try {
                        const text = await file.text();
                        allText += '\n' + text;
                    } catch (e) {
                        console.error(`Error reading file ${file.name}:`, e);
                    }
                } else {
                    showAlert(`File "<strong>${file.name}</strong>" is already in the list and was not added again.`, 'Duplicate File');
                }
            }
            
            this.textArea.value = (this.textArea.value.trim() + '\n' + allText.trim()).trim();
            this.renderFilePreviews();
            const LATENCY_THRESHOLD_BYTES = 2048000;
            if (totalNewSize > LATENCY_THRESHOLD_BYTES) {
                const sizeInMB = (totalNewSize / 1048576).toFixed(2);
                setTimeout(() => {
                     showAlert(`⚠️ **High Latency Alert:** You uploaded ${sizeInMB} MB. Processing datasets this large in the browser can lead to significant lag or crashes. For better performance, consider using the **AWS S3 Storage** streaming option.`, 'Performance Warning');
                }, 100);
            }
        }

        // Simplified S3 connection, just triggers fetch
        connectAwsS3() {
            const s3Url = prompt(
                "Enter the full **Pre-Signed S3 URL** or **Public URL** of the file (.txt, .csv, .md).\n\n" +
                "NOTE: A server-side component is REQUIRED for private S3 access."
            );
            if (s3Url) {
                const isFileUrl = s3Url.toLowerCase().startsWith('http') && (s3Url.toLowerCase().endsWith('.txt') || s3Url.toLowerCase().endsWith('.csv') || s3Url.toLowerCase().endsWith('.md'));
                if (isFileUrl) {
                    this.fetchDataFromCloud(s3Url);
                } else {
                    showAlert(`Invalid URL format detected. Please enter a direct file URL.`, 'URL Error');
                }
            }
        }

        async fetchDataFromCloud(url) {
            let totalBytesStreamed = 0;
            let objectContentLength = null;
            let isFirstChunk = true;
            const fileName = url.split('/').pop().split('?')[0] || 'aws_data.txt';

            currentStreamController = new AbortController();
            const signal = currentStreamController.signal;

            progressBarContainer.style.display = 'flex';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressBarContainer.querySelector('button').style.display = 'block';
            
            document.getElementById('file-analytics-summary').innerHTML = `<strong>Streaming ${fileName}...</strong>`;

            try {
                const response = await fetch(url, { signal });
                if (!response.ok) throw new Error(`HTTP Error ${response.status}. URL may be expired, or there's a CORS issue.`);

                if (response.headers.has('Content-Length')) {
                    objectContentLength = parseInt(response.headers.get('Content-Length'), 10);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    if (signal.aborted) break;
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunkText = decoder.decode(value, { stream: true });
                    
                    if (isFirstChunk) {
                        this.textArea.value = this.textArea.value.trim();
                        if (this.textArea.value.length > 0) { this.textArea.value += '\n'; }
                        isFirstChunk = false;
                    }
                    
                    this.textArea.value += chunkText;
                    totalBytesStreamed += value.length;
                    
                    if (objectContentLength) {
                        const percentage = Math.min(100, Math.round((totalBytesStreamed / objectContentLength) * 100));
                        progressBar.style.width = `${percentage}%`;
                        progressBar.textContent = `${percentage}%`;
                    } else {
                        const streamedMB = (totalBytesStreamed / 1048576).toFixed(2);
                        progressBar.textContent = `${streamedMB} MB streamed...`;
                    }
                }
                
                this.textArea.value += decoder.decode();
                progressBarContainer.style.display = 'none';
                progressBarContainer.querySelector('button').style.display = 'none';

                const mockFile = { name: fileName, size: totalBytesStreamed, text: () => Promise.resolve(this.textArea.value.trim()) };
                this.allUploadedFiles.push(mockFile);
                this.renderFilePreviews();
                
                showAlert(`✅ Streaming Complete! Successfully appended ${ (totalBytesStreamed / 1048576).toFixed(2) } MB from S3 file: ${fileName}.`, 'Streaming Success');

            } catch (error) {
                progressBarContainer.style.display = 'none';
                progressBarContainer.querySelector('button').style.display = 'none';
                if (error.name === 'AbortError') {
                    showAlert('Streaming cancelled by user.', 'Cancellation');
                } else {
                    console.error("Cloud Streaming Error:", error);
                    showAlert(`❌ Error streaming cloud data: ${error.message}`, 'Streaming Error');
                }
            } finally {
                currentStreamController = null;
            }
        }
    }

    function cancelStreaming() {
        if (currentStreamController) {
            currentStreamController.abort();
        }
    }

    // Initialize instances
    const tokenizer = new Tokenizer();
    const dataHandler = new DataHandler(tokenizer);

    // Initial event listeners for file handling
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const filePreview = document.getElementById('file-preview');

    filePreview.addEventListener('click', (e) => {
        if (e.target.classList.contains('remove-file')) {
            const indexToRemove = parseInt(e.target.dataset.index);
            dataHandler.removeFile(indexToRemove);
        }
    });

    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); e.dataTransfer.dropEffect = 'copy'; });
    dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('drag-over'); });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); dataHandler.handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => { dataHandler.handleFiles(e.target.files); fileInput.value = null; });

    // #endregion Phase 2

    // #region Phase 3: Embedding & Model Core Upgrade (transformer.js)

    /**
     * Phase 3 Deliverable: MiniTransformer Class
     */
    class MiniTransformer {
        constructor(tokenizer) {
            this.tokenizer = tokenizer;
            this.model = null; // Stores the TensorFlow.js model
            this.isTrained = false;
        }

        // Mock Web Worker function (Phase 3 requirement)
        _offloadTensorOperation(operation, ...args) {
            return new Promise(resolve => {
                setTimeout(() => {
                    showAlert(`TensorFlow operation offloaded to a mock Web Worker. Running ${operation}...`, 'Worker Status');
                    if (operation === 'train') {
                        let mockLoss = Array(CONFIG.train.epochs).fill(0).map((_, i) => 0.5 * Math.exp(-i / 5));
                        resolve({ success: true, lossHistory: mockLoss });
                    } else {
                        resolve(null); 
                    }
                }, 100); 
            });
        }

        /**
         * Builds a minimal, dense-layer model structure using TF.js
         */
        buildModel() {
            if (state.vocabSize === 0) {
                 showAlert('Cannot build model: Tokenizer vocabulary is empty. Run Tokenize & Preprocess first.', 'Model Error');
                 return;
            }
            const vocabSize = state.vocabSize;
            const embedDim = CONFIG.embeddingDim;

            this.model = tf.sequential();
            
            // 1. Embedding Layer 
            this.model.add(tf.layers.embedding({
                inputDim: vocabSize + 1, 
                outputDim: embedDim,
                inputLength: 10, 
                name: 'embedding'
            }));

            // 2. Mock Self-Attention (Simplified Dense Layer for architecture demonstration)
            this.model.add(tf.layers.dense({ 
                units: embedDim, 
                activation: 'gelu', 
                name: 'attention_mock_layer'
            })); 

            // 3. Final Prediction Layer (to Vocab size)
            this.model.add(tf.layers.dense({
                units: vocabSize, 
                activation: 'softmax',
                name: 'output_projection'
            }));

            this.model.compile({
                optimizer: tf.train.adam(CONFIG.train.learningRate),
                loss: 'categoricalCrossentropy'
            });

            this.model.summary();
            showAlert('MiniTransformer model structure built successfully using TensorFlow.js.', 'Model Ready');
        }


        /**
         * Trains the model on the text corpus (Phase 3 Deliverable).
         */
        async trainOnText(corpus) {
            if (state.vocabSize === 0) {
                showAlert('Cannot train: Tokenizer vocabulary is empty. Run Tokenize & Preprocess first.', 'Training Error');
                return;
            }

            if (!this.model || this.model.isDisposed()) {
                this.buildModel();
            }

            // Mock Training Data Generation (since real data preparation is complex)
            const inputTensor = tf.randomUniform([CONFIG.train.batchSize, 10, CONFIG.embeddingDim]); 
            const outputTensor = tf.randomUniform([CONFIG.train.batchSize, CONFIG.embeddingDim, state.vocabSize]); 

            const { success, lossHistory } = await this._offloadTensorOperation('train', inputTensor, outputTensor);

            if (success) {
                this.isTrained = true;
                
                // Update Chart
                lossChart.data.labels = [];
                lossChart.data.datasets[0].data = [];
                
                lossHistory.forEach((loss, index) => {
                    state.currentLoss = loss;
                    state.epochsRun = index + 1;
                    lossChart.data.labels.push(`Step ${index + 1}`);
                    lossChart.data.datasets[0].data.push(loss);
                });
                lossChart.update();
                
                showAlert(`Mock training finished in ${CONFIG.train.epochs} epochs. Final Loss: ${state.currentLoss}.`, 'Training Complete');
                tf.dispose([inputTensor, outputTensor]);
            } else {
                 showAlert('Training simulation failed.', 'Training Failed');
            }
        }

        /**
         * Generates text based on the Transformer model (Phase 3 Deliverable).
         */
        async generate(prompt, maxTokens, temperature) {
            if (!this.model || !this.isTrained) {
                return '[ERROR] Model not trained or loaded. Please train first.';
            }

            const startTime = performance.now();
            
            const promptIds = this.tokenizer.encode(prompt).slice(-10); 
            let currentIds = [...promptIds];
            const maxSeq = 10;
            
            for (let i = 0; i < maxTokens; i++) {
                const lastTokenId = currentIds[currentIds.length - 1];
                const inputForNext = tf.oneHot(lastTokenId, state.vocabSize).expandDims(0);
                
                const mockOutput = tf.layers.dense({ 
                    units: state.vocabSize, 
                    activation: 'softmax' 
                }).apply(inputForNext);

                const nextTokenId = tf.tidy(() => {
                    const logits = mockOutput.squeeze();
                    const sampled = tf.div(tf.log(logits), temperature).softmax();
                    return tf.multinomial(sampled, 1).dataSync()[0];
                });
                
                currentIds.push(nextTokenId);
                tf.dispose([inputForNext, mockOutput]);

                if (i > maxTokens - 2) break;
            }

            const endTime = performance.now();
            state.latency = `${(endTime - startTime).toFixed(2)} ms`;
            
            return this.tokenizer.decode(currentIds);
        }

        saveModel() {
            if (this.model) {
                const memory = tf.memory();
                const modelSizeMB = (memory.numBytes / 1048576).toFixed(2);
                document.getElementById('metric-memory').textContent = `${modelSizeMB} MB`;
                showAlert(`Mock Model saved! Size: ${modelSizeMB} MB. (Weights not actually persisted in this prototype.)`, 'Save Status');
            } else {
                showAlert('No model to save. Build or train the model first.', 'Save Error');
            }
        }

        loadModel() {
            this.buildModel();
            this.isTrained = true;
            state.epochsRun = 10;
            state.currentLoss = 0.1567;
            showAlert('Mock Model loaded successfully! (Random weights assigned for prototype).', 'Load Status');
        }
    }

    // Initialize MiniTransformer
    const miniTransformer = new MiniTransformer(tokenizer);

    // #endregion Phase 3

    // #region Phase 4: UI Enhancements & Generation Logic

    /**
     * Executes the appropriate generation method based on the current mode.
     */
    async function generateTextFromModel() {
        const prompt = document.getElementById('prompt-input').value.trim() || 'The';
        const maxTokens = parseInt(document.getElementById('max-tokens-input').value);
        const temperature = parseFloat(document.getElementById('temperature-input').value);
        let outputText = '';

        document.getElementById('llm-output').textContent = 'Generating...';

        try {
            if (state.mode === 'MARKOV') {
                const startTime = performance.now();
                outputText = generateMarkovText(dataHandler.markovMatrix, prompt, maxTokens);
                const endTime = performance.now();
                state.latency = `${(endTime - startTime).toFixed(2)} ms`;
            } else if (state.mode === 'TRANSFORMER') {
                 if (state.vocabSize === 0) throw new Error("Tokenizer data is missing. Run Tokenize & Preprocess.");
                outputText = await miniTransformer.generate(prompt, maxTokens, temperature);
            } else {
                outputText = 'Invalid model mode selected.';
            }
        } catch (e) {
            console.error('Generation Error:', e);
            outputText = `[GENERATION ERROR] ${e.message}. Ensure data is tokenized and model is trained.`;
        }

        document.getElementById('llm-output').textContent = outputText;
    }

    /**
     * Legacy Markov Generation (markov.js fallback)
     */
    function generateMarkovText(matrix, prompt, maxWords) {
        let words = prompt.toLowerCase().split(/\s+/).filter(w => w.length > 0);
        let currentWord = words[words.length - 1] || Object.keys(matrix)[0];
        let generated = [...words];

        if (!currentWord || !matrix[currentWord]) {
             return '[MARKOV ERROR] Prompt word not found in corpus, or corpus is too small. Try a common word like "the" or "a".';
        }

        for (let i = 0; i < maxWords; i++) {
            const nextWords = matrix[currentWord];
            if (!nextWords) break;

            const candidates = [];
            for (const w in nextWords) {
                for (let k = 0; k < nextWords[w]; k++) candidates.push(w);
            }

            const nextWord = candidates[Math.floor(Math.random() * candidates.length)];
            if (!nextWord) break;
            generated.push(nextWord);
            currentWord = nextWord;
        }

        return generated.join(' ');
    }

    // #endregion Phase 4

    // Initial setup on load
    window.onload = () => {
        initializeLossChart(); 
        initializeTokenChart(); // Initialize token chart too
        dataHandler.updateFileAnalyticsSummary();
        // Hide Transformer elements initially
        document.getElementById('model-controls-panel').style.display = 'none';
        document.getElementById('model-dashboard').style.display = 'none';
    };

</script>
</body>
</html>

